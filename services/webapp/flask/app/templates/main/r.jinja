{% extends 'layout.jinja' %}

{% block debug %}

    <!-- {% if level == "DEBUG" %} -->
    <!-- DEBUG INFO -->
    
    <!-- user.id: {{user.id}} -->
    <!-- user.name: {{user.name}} -->
    <!-- is_authenticated: {{user.is_authenticated}} -->
    <!-- is_anonymous: {{user.is_anonymous}} -->

    <!-- Session Cookies -->
    {% for key, value in request_cookies.items() %}
    <!-- {{ key }}: {{ value }} -->
    {% endfor %}

    <!-- Session -->
    {% for key, value in session.items() %}
    <!-- {{ key }}: {{ value }} -->
    {% endfor %}

    <!-- {% endif %} -->

{% endblock %}

{% block head %}

    <title>Tapis Vert::{{room.name}}</title>

    {% include 'main/elements/room.jinja' %}
    {% include 'auth/self.jinja' %}

{% endblock %}

{% block body %}


    <script>


    // represntations of the room and its elements
    class RoomManager {

        constructor() {

            console.log("Create RoomManager") ;

            // room data - mirrors backend data
            this.data = {} ;

            // room representations
            this.eTable = new Table() ;
            this.eRoomFooterEntry = new RoomFooterEntry() ;

            // users representations
            this.eUsers = {} ;

            // cards representations
            this.eCards = {} ;

            // Listens when a new user joins the room
            listen( "RoomManager", "user:joined", (throwerId, user_id) => {
                this.sync()
                .then( _ => this.render() ) ;
            })

            // Listens when a new user leaves the room
            listen( "RoomManager", "user:left", (throwerId, user_id) => {
                this.sync()
                .then( _ => this.render() ) ;
            })

            // Listens when a room's user turns online
            listen( "RoomManager", "user:online", (throwerId, user_id) => {
                find(this.data.users, "id", user_id).status = "online" ;
                this.eUsers[user_id].status  = "online" ;
            })

            // Listens when a room's user turns offline
            listen( "RoomManager", "user:offline", (throwerId, user_id) => {
                find(this.data.users, "id", user_id).status = "offline" ;
                this.eUsers[user_id].status  = "offline" ;
            })

            // Listens when a user beocmes player
            listen( "RoomManager", "user:player", (throwerId, user_id) => {
                find(this.data.users, "id", user_id).role = "player" ;
                this.eUsers[user_id].role    = "player" ;
            })

            // Listens when a user beocmes watcher
            listen( "RoomManager", "user:watcher", (throwerId, user_id) => {
                find(this.data.users, "id", user_id).role = "watcher" ;
                this.eUsers[user_id].role    = "watcher" ;
            })

            // Listens when a user beocmes master
            listen( "RoomManager", "user:master", (throwerId, user_id) => {
                find(this.data.users, "id", user_id).role = "master" ;
                this.eUsers[user_id].role    = "master" ;
            })

            // Listens for a new round 
            listen( "RoomManager", "round:new", (throwerId, user_id) => {
                
                Object.values(this.eCards).forEach(cardObj => cardObj.remove());
                
                this.sync()
                .then( _ => this.render() ) ;
            })

        }

        // (re)initializes the room data, synchronizing it with backend
        sync() {

            return call('GET', '/api/v1/rooms/{{room.id}}')
                    .then( r => r.json() )
                    .then( r => this.data = r )

        }

        // Renders the room
        render() {

            // RENDER USERS ----

            // remove users which are not in the room anymore
            // TODO Replace with Object.keys(this.eUsers).forEach(...)
            for (let id in this.eUsers) {
                if (!this.data.users.some(userDATA => userDATA.id == id)) {
                    this.eUsers[id].remove() ;
                    delete this.eUsers[id] ;
                }
            }

            this.data.users.forEach( userDATA => {

                // adds user if does not exist
                if (!this.eUsers[userDATA.id]) {
                    this.createUser(userDATA.id) ;
                }

                // renders user
                this.eUsers[userDATA.id].name    = userDATA.name ;
                this.eUsers[userDATA.id].status  = userDATA.relation.status ;
                this.eUsers[userDATA.id].role    = userDATA.relation.role ;
            
            });


            // RENDER CARDS ----

            this.data.round.cards.forEach( cardDATA => {

                // adds card if does not exist
                if (!this.eCards[cardDATA.value]) {
                    this.createCard(cardDATA.value) ;
                }

                // renders card
                this.eCards[cardDATA.value].value      = cardDATA.value ;
                this.eCards[cardDATA.value].owner      = find(this.data.users, "id", cardDATA.player_id).name ;
                this.eCards[cardDATA.value].peeked     = cardDATA.peeked ;
                this.eCards[cardDATA.value].flipped    = cardDATA.flipped ;

                // assigns card to user
                this.eUsers[cardDATA.player_id].assignCard(this.eCards[cardDATA.value]);

            });

        }


        // Creates a user object given a user_id 
        createUser(user_id) {

            if (this.eUsers[user_id]) {
                console.error(`User with id ${user_id} already exists`);
                return ;
            }
            console.log(`Create user with id ${user_id}`) ;

            this.eUsers[user_id] = {

                // representation of user's deck
                eUserDeck: new Deck(),

                // representation of the user in thr footer
                eUserFooter: new UserFooter(),

                remove() {
                    this.eUserFooter.remove();
                },

                set name(name) {
                    this.eUserFooter.name = name ;
                },
                set status(status) {
                    this.eUserFooter.online = status ;
                },
                set role(role) {
                    this.eUserFooter.role = role ;
                },

                assignCard(cardOBJ) {                    
                    this.eUserDeck.card = cardOBJ.eCard.e ;
                }

            } ;

        }

        // creates a card object
        createCard(card_id) {

            if (this.eCards[card_id]) {
                console.error(`Card with id ${card_id} already exists`) ;
                return ;
            }

            console.log(`Create card with id ${card_id}`) ;
            this.eCards[card_id] = {

                // representation of the card
                eCard: new Card(),

                remove() {
                    this.eCard.remove();
                },

                set value(value) { 
                    this.eCard.value    = value                     
                },
                set owner(owner) { 
                    this.eCard.owner    = owner ; 
                },                
                set peeked(bool) {
                    this.eCard.peeked   = bool ; 
                },
                set flipped(bool) {
                    this.eCard.flipped  = bool ;
                }

            } ;

        }


    };
    </script>

    <!-- LISTENERS ------ ------ ------ ------ -->
    <script>

    let ROOMWS // Room WebSocket


    const SELF = new SelfFooterEntry()

    document.addEventListener('DOMContentLoaded', () => {

        // Join room
        call('POST', '/api/v1/rooms/{{room.id}}/join')

        let ROOM = new RoomManager()

        ROOM.sync()
        .then( _ => ROOM.render() )
        .then( _ => ROOMWS = new EventWebSocket("/ws/{{room.id}}/{{user.id}}") )

    });

    </script>


{% endblock %}

