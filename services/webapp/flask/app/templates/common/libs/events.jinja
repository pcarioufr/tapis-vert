<!-- EVENTS ------ ------ ------ ------ -->

    <script>

    /**
    * Each listener is stored as an object:
    * {
    *   listenerId: string,
    *   pattern: string,  // can be exact name or pattern with wildcards
    *   callback: function
    * }
    */
    const LISTENERS = [];

    /**
    * Fire: triggers any listener whose pattern matches the eventName.
    * @param {string} throwerId
    * @param {string} eventName
    * @param {*} data
    */
    function fire(throwerId, eventName, data = null) {
        // Loop through all listener entries
        LISTENERS.forEach(({ listenerId, pattern, callback }) => {
            if (eventMatchesPattern(eventName, pattern)) {
                callback.call(this, throwerId, data, eventName);
            }
        });
    }

    /**
    * Listen: register a callback for an event name or a wildcard pattern.
    * @param {string} listenerId
    * @param {string} pattern
    * @param {function} callback
    */
    function listen(listenerId, pattern, callback) {
        if (typeof listenerId !== 'string' || listenerId.trim() === '') {
            throw new Error("Listener ID must be a non-empty string.");
        }
        if (typeof pattern !== 'string' || pattern.trim() === '') {
            throw new Error("Event pattern must be a non-empty string.");
        }

        // Create a new listener entry
        LISTENERS.push({
            listenerId,
            pattern,
            callback
        });
    }

    /**
    * Ignore: unregister a listener from a given pattern (or exact event).
    * @param {string} listenerId
    * @param {string} pattern
    */
    function ignore(listenerId, pattern) {
        if (typeof listenerId !== 'string' || listenerId.trim() === '') {
            throw new Error("Listener ID must be a non-empty string.");
        }
        if (typeof pattern !== 'string' || pattern.trim() === '') {
            throw new Error("Event pattern must be a non-empty string.");
        }

        // Filter out the matching listener(s)
        for (let i = LISTENERS.length - 1; i >= 0; i--) {
            const entry = LISTENERS[i];
            if (entry.listenerId === listenerId && entry.pattern === pattern) {
                LISTENERS.splice(i, 1);
            }
        }
    }

    /**
    * Helper: Does the eventName match a given pattern?
    * - If pattern has no special wildcard characters, it must match exactly.
    * - If pattern contains wildcard(s) like '*', we do a simple conversion to RegExp.
    *
    * @param {string} eventName
    * @param {string} pattern
    * @returns {boolean}
    */
    function eventMatchesPattern(eventName, pattern) {
        // Quick optimization if there's no wildcard in the pattern
        if (!pattern.includes('*')) {
            return (eventName === pattern);
        }

        // Convert the pattern to a RegExp: 
        // 1) Escape all regex meta-characters except `*`.  
        // 2) Replace `*` with `.*` 
        // 3) Anchor ^ and $
        const regexStr = '^' + pattern
            .replace(/[.+?^${}()|[\]\\]/g, '\\$&') // Escape everything except '*'
            .replace(/\*/g, '.*') + '$';

        const regex = new RegExp(regexStr);
        return regex.test(eventName);
    }


    </script>


    <!-- WEBSOCKETS ------ ------ ------ ------ -->

    <script>

    class EventWebSocket extends WebSocket {


        constructor(wsurl) {

            super(wsurl);  // Call the WebSocket constructor
            this.wsurl = wsurl;

            this.delay = 5000; // Delay before reconnecting

            this.onmessage = (event) => {
                let [key, value] = event.data.split('::', 2);
                try { value = JSON.parse(value); } 
                catch (e) { /* If not JSON, just use raw value */ }
                fire("websocket", key, value);
            };

            this.onopen = _ => {
                console.log("WebSocket connection established");
            };

            this.onclose = event => {
                new Toast("error", "Lost connection with room.", this.delay - 1000);
                this.tryReconnect();
            };

        }

        // this.send(), but waiting for the websocket connection to open.
        // key will be prefixed by user:{{user.id}}: by the server
        async send(key, value, timeout = 5000) {

            const startTime = Date.now();

            const trySend = _ => {
                if (this.readyState === 1) {  // Check if WebSocket is open
                    super.send(`${key}::${value}`);
                    return true; // Successfully sent
                }
                return false; // Not ready
            };

            while (!trySend()) {
                if (Date.now() - startTime > timeout) {
                    console.error("WebSocket connection timed out");
                    return; // Exit the function after a timeout
                }
                await wait(5); // Pause for 5ms before retrying
            }
        }

        async tryReconnect() {

            await wait(this.delay);

            const newWs = new EventWebSocket(this.wsurl);
            newWs.onopen = _ => {
                new Toast("ok", "Recovered connection with room.");
                Object.assign(this, newWs);
                fire ("EventWebSocket", "ws:reconnected", newWs);
            };

        }

    }

    </script>
