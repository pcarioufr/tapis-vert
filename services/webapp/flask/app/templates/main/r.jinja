{% extends 'layout.jinja' %}

{% block debug %}

    <!-- {% if level == "DEBUG" %} -->
    <!-- DEBUG INFO -->
    
    <!-- user.id: {{user.id}} -->
    <!-- user.name: {{user.name}} -->
    <!-- is_authenticated: {{user.is_authenticated}} -->
    <!-- is_anonymous: {{user.is_anonymous}} -->

    <!-- Session Cookies -->
    {% for key, value in request_cookies.items() %}
    <!-- {{ key }}: {{ value }} -->
    {% endfor %}

    <!-- Session -->
    {% for key, value in session.items() %}
    <!-- {{ key }}: {{ value }} -->
    {% endfor %}

    <!-- {% endif %} -->

{% endblock %}

{% block head %}

    <title>Tapis Vert::{{room.name}}</title>

    {% include 'main/elements/room.jinja' %}
    {% include 'auth/self.jinja' %}

{% endblock %}

{% block body %}


    <script>


    // represntations of the room and its elements
    class RoomManager {

        constructor() {

            // room data - mirrors backend data
            this.data = {} ;

            // room representations
            this.eTable = new Table() ;
            this.eRoomFooterEntry = new RoomFooterEntry() ;

            // users representations
            this.eUsers = {} ;

            // cards representations
            this.eCards = {} ;

            // Listens when a new user joins the room
            listen( "RoomManager", "user:joined", (throwerId, user_id) => {
                this.sync()
                .then( _ => this.render() ) ;
            })

            // Listens when a new user leaves the room
            listen( "RoomManager", "user:left", (throwerId, user_id) => {
                this.sync()
                .then( _ => this.render() ) ;
            })

            // Listens when a room's user turns online
            listen( "RoomManager", "user:online", (throwerId, user_id) => {
                find(this.data.users, "id", `${user_id}`).relation.status = "online" ;                
                this.eUsers[user_id].status  = "online" ;
            })

            // Listens when a room's user turns offline
            listen( "RoomManager", "user:offline", (throwerId, user_id) => {
                find(this.data.users, "id", `${user_id}`).relation.status = "offline" ;
                this.eUsers[user_id].status  = "offline" ;
            })

            // Listens when a user beocmes player
            listen( "RoomManager", "user:player", (throwerId, user_id) => {
                find(this.data.users, "id", `${user_id}`).role = "player" ;
                this.eUsers[user_id].role    = "player" ;
            })

            // Listens when a user beocmes watcher
            listen( "RoomManager", "user:watcher", (throwerId, user_id) => {
                find(this.data.users, "id", `${user_id}`).role = "watcher" ;
                this.eUsers[user_id].role    = "watcher" ;
            })

            // Listens when a user beocmes master
            listen( "RoomManager", "user:master", (throwerId, user_id) => {
                find(this.data.users, "id", `${user_id}`).role = "master" ;
                this.eUsers[user_id].role    = "master" ;
            })

            // Listens for a new round 
            listen( "RoomManager", "round:new", (throwerId, user_id) => {
                
                values(this.eCards).forEach(cardObj => cardObj.remove());
                
                this.sync()
                .then( _ => this.render() ) ;
            })

            // Listens for a card peeked event
            listen( "RoomManager", "cards.*.peeked.*", (throwerId, update, eventName) => {

                console.debug(`Card update: ${eventName} = ${update}`) ;

                let [_1, card_id, _3, user_id] = eventName.split('.');
                let card = this.data.cards[card_id]

                card.peeked[user_id] = update ;

                // if the card peeked is self's
                if (user_id === "{{user.id}}") {
                    this.eCards[card_id].peekedL = update;
                } 
                // if the card peeked is other user's
                else {
                    switch (update) {
                        case "True":
                            this.eCards[card_id].peekedU = "True";
                            break;
                       case "False":
                            const others = fromEntries( entries(card.peeked).filter(([key, _]) => key !== "{{user.id}}" ));
                            values(others).every( val => val === "False" ) ?
                                this.eCards[card_id].peekedU = "False" :
                                this.eCards[card_id].peekedU = "True" ;
                            break;
                    }
                }
 
            })

            // Listens for a card flipped event
            listen( "RoomManager", "cards.*.flipped", (throwerId, update, eventName) => {

                this.data.cards[card_id].flipped = update ;

                let [_, cardID, property] = eventName.split('.');
                this.eCards[cardID][property] = update;

            })

        }

        // (re)initializes the room data, synchronizing it with backend
        sync() {

            return call('GET', '/api/v1/rooms/{{room.id}}')
                    .then( r => r.json() )
                    .then( r => this.data = r )

        }

        // Renders the room
        render() {

            // RENDER USERS ----

            // remove users which are not in the room anymore
            // TODO Replace with Object.keys(this.eUsers).forEach(...)
            for (let id in this.eUsers) {
                if (!this.data.users.some(userDATA => userDATA.id == id)) {
                    this.eUsers[id].remove() ;
                    delete this.eUsers[id] ;
                }
            }

            this.data.users.forEach( userDATA => {

                // adds user if does not exist
                if (!this.eUsers[userDATA.id]) {
                    this.createUser(userDATA.id) ;
                }

                // renders user
                this.eUsers[userDATA.id].name    = userDATA.name ;
                this.eUsers[userDATA.id].status  = userDATA.relation.status ;
                this.eUsers[userDATA.id].role    = userDATA.relation.role ;
            
            });


            // RENDER CARDS ----

            entries(this.data.cards).forEach( ([card_id, card]) => {

                // ADDS CARD IF DOES NOT EXIST

                if ( !this.eCards[card_id] ) { this.createCard(card_id) ; }

                // RENDERS CARD

                this.eCards[card_id].value  = card.value ;
                this.eCards[card_id].owner  = find(this.data.users, "id", card.player_id).name ;

                // lower-peeked property - for self
                card.peeked["{{user.id}}"] === "True" ?
                    this.eCards[card_id].peekedL = "True" :
                    this.eCards[card_id].peekedL = "False"

                // upper-peeked property - for other users
                const others = fromEntries( entries(card.peeked).filter(([key, _]) => key !== "{{user.id}}" ));
                values(others).every( val => val === "False" ) ?
                    this.eCards[card_id].peekedU = "False" :
                    this.eCards[card_id].peekedU = "True" ;

                // flpped property
                this.eCards[card_id].flipped    = card.flipped ;

                // assigns card to user
                this.eUsers[card.player_id].assignCard(this.eCards[card_id]);

            });

        }


        // Creates a user object given a user_id 
        createUser(user_id) {

            if (this.eUsers[user_id]) {
                console.error(`User with id ${user_id} already exists`);
                return ;
            }
            console.log(`Create user with id ${user_id}`) ;

            this.eUsers[user_id] = {

                // representation of user's deck
                eUserDeck: new Deck(),

                // representation of the user in thr footer
                eUserFooter: new UserFooter(),

                remove() {
                    this.eUserFooter.remove();
                },

                set name(name) {
                    this.eUserFooter.name = name ;
                },
                set status(status) {
                    this.eUserFooter.status = status ;
                },
                set role(role) {
                    this.eUserFooter.role = role ;
                },

                assignCard(cardOBJ) {                    
                    this.eUserDeck.card = cardOBJ.eCard.e ;
                }

            } ;

        }

        // creates a card object
        createCard(card_id) {

            if (this.eCards[card_id]) {
                console.error(`Card with id ${card_id} already exists`) ;
                return ;
            }

            console.log(`Create card with id ${card_id}`) ;
            this.eCards[card_id] = {

                // representation of the card
                eCard: new Card(card_id),

                remove() {
                    this.eCard.remove();
                },

                set value(value) { 
                    this.eCard.value    = value                     
                },
                set owner(owner) { 
                    this.eCard.owner    = owner ; 
                },                
                set peekedU(isPeeked) {
                    isPeeked  == "True" ? isPeeked = true  : isPeeked = false ;
                    this.eCard.peekedU   = isPeeked ; 
                },
                set peekedL(isPeeked) {
                    isPeeked  == "True" ? isPeeked = true  : isPeeked = false ;
                    this.eCard.peekedL   = isPeeked ; 
                },
                set flipped(isFlipped) {
                    isFlipped == "True" ? isFlipped = true : isFlipped = false ;
                    this.eCard.flipped  = isFlipped ;
                }

            } ;

        }


    };
    </script>

    <!-- LISTENERS ------ ------ ------ ------ -->
    <script>

    let ROOMWS // Room WebSocket
    let ROOM = new RoomManager() // Room Manager

    const SELF = new SelfFooterEntry()

    document.addEventListener('DOMContentLoaded', () => {

        // Join room
        call('POST', '/api/v1/rooms/{{room.id}}/join')

        ROOM.sync()
        .then( _ => ROOM.render() )
        .then( _ => ROOMWS = new EventWebSocket("/ws/{{room.id}}/{{user.id}}") )

    });

    </script>


{% endblock %}

